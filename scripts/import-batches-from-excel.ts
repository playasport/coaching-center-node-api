/**
 * Import batches into MongoDB from the Excel file generated by export-mysql-tables-to-excel.ts
 *
 * Reads the exported Excel, resolves centerId ‚Üí CoachingCenter._id and sportId ‚Üí Sport._id,
 * then creates new Batch documents in MongoDB.
 *
 * Run: npm run import:batches-excel
 * or:  npm run import:batches-excel:dry-run
 * or:  tsx scripts/import-batches-from-excel.ts [--dry-run] [path-to-excel]
 *
 * If no path is given, picks the latest file from exports/ matching batches-export-*.xlsx
 */

import 'dotenv/config';
import * as fs from 'fs';
import * as path from 'path';
import ExcelJS from 'exceljs';
import { connectDatabase, disconnectDatabase } from '../src/config/database';
import { CoachingCenterModel } from '../src/models/coachingCenter.model';
import { SportModel } from '../src/models/sport.model';
import { BatchModel } from '../src/models/batch.model';
import { BatchStatus } from '../src/enums/batchStatus.enum';
import { Types } from 'mongoose';

const EXPORTS_DIR = path.join(process.cwd(), 'exports');
const LOGS_DIR = path.join(process.cwd(), 'logs');
const DRY_RUN = process.argv.includes('--dry-run');

function getExcelPath(): string {
  const args = process.argv.filter((a) => !a.startsWith('--'));
  const filePath = args[args.length - 1];

  if (!filePath || filePath.endsWith('.ts') || filePath.endsWith('.js')) {
    console.error('‚ùå Please provide the Excel file path');
    console.error('   Usage: npm run import:batches-excel -- <file-path>');
    console.error('   Example: npm run import:batches-excel -- ./exports/fee-structures-export.xlsx');
    process.exit(1);
  }

  const resolved = path.resolve(filePath);
  if (!fs.existsSync(resolved)) {
    console.error(`‚ùå File not found: ${resolved}`);
    process.exit(1);
  }
  return resolved;
}

const parseNumber = (v: any): number | null => {
  if (v === null || v === undefined || v === '') return null;
  if (typeof v === 'number' && !isNaN(v)) return v;
  const n = parseFloat(String(v).trim());
  return isNaN(n) ? null : n;
};

const parseBoolean = (v: any): boolean => {
  if (typeof v === 'boolean') return v;
  const s = String(v).toLowerCase().trim();
  return s === 'true' || s === '1' || s === 'yes';
};

const parseCommaList = (v: any): string[] => {
  if (!v) return [];
  const s = String(v).trim();
  if (!s) return [];
  return s.split(',').map((x) => x.trim().toLowerCase()).filter(Boolean);
};

const parseJsonArray = (v: any): any[] | null => {
  if (!v) return null;
  const s = String(v).trim();
  if (!s) return null;
  try {
    const arr = JSON.parse(s);
    return Array.isArray(arr) ? arr : null;
  } catch {
    return null;
  }
};

async function main() {
  try {
    const excelPath = getExcelPath();
    console.log(`\nüì• Importing batches from Excel...`);
    console.log(`   File: ${excelPath}`);
    if (DRY_RUN) console.log('   üîç DRY RUN - no changes will be made');
    console.log('');

    await connectDatabase();
    console.log('‚úÖ Database connected\n');

    // Pre-load center and sport lookup maps
    console.log('  üì¶ Loading coaching centers...');
    const centers = await CoachingCenterModel.find({ is_deleted: false })
      .select('_id id user')
      .lean();
    const centerByUuid = new Map<string, { _id: Types.ObjectId; user: Types.ObjectId }>();
    for (const c of centers as any[]) {
      centerByUuid.set(c.id, { _id: c._id, user: c.user });
    }
    console.log(`    ‚Üí ${centerByUuid.size} centers loaded`);

    console.log('  üì¶ Loading sports...');
    const sports = await SportModel.find().select('_id custom_id').lean();
    const sportByCustomId = new Map<string, Types.ObjectId>();
    for (const s of sports as any[]) {
      sportByCustomId.set(s.custom_id, s._id);
    }
    console.log(`    ‚Üí ${sportByCustomId.size} sports loaded\n`);

    // Read Excel
    const workbook = new ExcelJS.Workbook();
    await workbook.xlsx.readFile(excelPath);
    const worksheet = workbook.getWorksheet('Batches') ?? workbook.worksheets[0];
    if (!worksheet) {
      console.error('‚ùå No worksheet found in Excel file');
      process.exit(1);
    }
    console.log(`  üìÑ Using worksheet: "${worksheet.name}"\n`);

    // Build column map from headers
    const headerRow = worksheet.getRow(1);
    const colMap: Record<string, number> = {};
    headerRow.eachCell((cell, colNumber) => {
      const key = cell.value?.toString()?.trim()?.toLowerCase();
      if (key && !colMap[key]) colMap[key] = colNumber;
    });

    const col = (key: string): number => colMap[key] ?? -1;
    const cellVal = (row: ExcelJS.Row, key: string): any => {
      const c = col(key);
      return c > 0 ? row.getCell(c).value : undefined;
    };
    const cellStr = (row: ExcelJS.Row, key: string): string => {
      const v = cellVal(row, key);
      return v != null ? String(v).trim() : '';
    };

    const totalRows = worksheet.rowCount - 1;
    console.log(`  üìä Total rows to process: ${totalRows}\n`);

    let created = 0;
    let skipped = 0;
    const errors: Array<{ row: number; name: string; message: string }> = [];

    const allRows = worksheet.getRows(2, totalRows) || [];

    for (let i = 0; i < allRows.length; i++) {
      const row = allRows[i];
      const rowNum = i + 2;

      const batchName = cellStr(row, 'batch_name');
      if (!batchName) {
        skipped++;
        continue;
      }

      const centerId = cellStr(row, 'centerid');
      const sportId = cellStr(row, 'sportid');

      if (!centerId) {
        errors.push({ row: rowNum, name: batchName, message: 'Missing centerId' });
        continue;
      }
      if (!sportId) {
        errors.push({ row: rowNum, name: batchName, message: 'Missing sportId' });
        continue;
      }

      const centerDoc = centerByUuid.get(centerId);
      if (!centerDoc) {
        errors.push({ row: rowNum, name: batchName, message: `Center not found: ${centerId}` });
        continue;
      }

      const sportObjectId = sportByCustomId.get(sportId);
      if (!sportObjectId) {
        errors.push({ row: rowNum, name: batchName, message: `Sport not found: ${sportId}` });
        continue;
      }

      // Parse fields
      const description = cellStr(row, 'description') || null;
      const genders = parseCommaList(cellStr(row, 'gender'));
      const validGenders = genders.filter((g) => ['male', 'female', 'other'].includes(g));
      if (validGenders.length === 0) validGenders.push('male', 'female');

      const certificateIssued = parseBoolean(cellVal(row, 'certificate_issued'));
      const isAllowedDisabled = parseBoolean(cellVal(row, 'is_allowed_disabled'));

      const startDateStr = cellStr(row, 'start_date');
      const endDateStr = cellStr(row, 'end_date');
      const startDate = startDateStr ? new Date(startDateStr) : new Date();
      const endDate = endDateStr ? new Date(endDateStr) : null;

      if (isNaN(startDate.getTime())) {
        errors.push({ row: rowNum, name: batchName, message: `Invalid start_date: ${startDateStr}` });
        continue;
      }

      const trainingDays = parseCommaList(cellStr(row, 'training_days'));
      const validDays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
      const filteredDays = trainingDays.filter((d) => validDays.includes(d));
      if (filteredDays.length === 0) {
        errors.push({ row: rowNum, name: batchName, message: 'No valid training_days' });
        continue;
      }

      const individualTimingsRaw = parseJsonArray(cellStr(row, 'individual_timings'));
      let individualTimings: Array<{ day: string; start_time: string; end_time: string }> | null = null;
      if (individualTimingsRaw && individualTimingsRaw.length > 0) {
        const timeRegex = /^([0-1][0-9]|2[0-3]):[0-5][0-9]$/;
        individualTimings = individualTimingsRaw.filter(
          (t: any) =>
            t && typeof t === 'object' &&
            t.day && validDays.includes(t.day.toLowerCase()) &&
            timeRegex.test(t.start_time) &&
            timeRegex.test(t.end_time)
        ).map((t: any) => ({
          day: t.day.toLowerCase(),
          start_time: t.start_time,
          end_time: t.end_time,
        }));
        if (individualTimings.length === 0) individualTimings = null;
      }

      const durationCount = parseNumber(cellVal(row, 'duration_count')) ?? 1;
      const durationTypeRaw = cellStr(row, 'duration_type').toLowerCase() || 'month';
      const validDurationTypes = ['day', 'month', 'week', 'year'];
      const durationType = validDurationTypes.includes(durationTypeRaw) ? durationTypeRaw : 'month';

      const capacityMin = parseNumber(cellVal(row, 'capacity_min')) ?? 1;
      const capacityMax = parseNumber(cellVal(row, 'capacity_max')) ?? 10000;

      let ageMin = parseNumber(cellVal(row, 'age_min')) ?? 3;
      let ageMax = parseNumber(cellVal(row, 'age_max')) ?? 18;
      ageMin = Math.max(3, Math.min(18, ageMin));
      ageMax = Math.max(3, Math.min(18, ageMax));
      if (ageMax < ageMin) ageMax = ageMin;

      const admissionFee = parseNumber(cellVal(row, 'admission_fee'));
      const basePrice = parseNumber(cellVal(row, 'base_price')) ?? 0;
      const discountedPriceRaw = parseNumber(cellVal(row, 'discounted_price'));
      const discountedPrice = discountedPriceRaw && discountedPriceRaw > 0 ? discountedPriceRaw : null;

      const truncatedName = batchName.length > 50 ? batchName.substring(0, 50) : batchName;

      const batchDoc = {
        user: centerDoc.user,
        name: truncatedName,
        description: description ? description.substring(0, 1000) : null,
        sport: sportObjectId,
        center: centerDoc._id,
        coach: null,
        gender: validGenders,
        certificate_issued: certificateIssued,
        scheduled: {
          start_date: startDate,
          end_date: endDate,
          start_time: null,
          end_time: null,
          individual_timings: individualTimings,
          training_days: filteredDays,
        },
        duration: {
          count: Math.max(1, Math.min(1000, durationCount)),
          type: durationType,
        },
        capacity: {
          min: Math.max(1, capacityMin),
          max: Math.min(10000, capacityMax),
        },
        age: {
          min: ageMin,
          max: ageMax,
        },
        admission_fee: admissionFee,
        base_price: basePrice,
        discounted_price: discountedPrice,
        is_allowed_disabled: isAllowedDisabled,
        status: BatchStatus.PUBLISHED,
        is_active: true,
        is_deleted: false,
      };

      if (!DRY_RUN) {
        try {
          await BatchModel.create(batchDoc);
          created++;
        } catch (err) {
          const msg = err instanceof Error ? err.message : 'Create failed';
          errors.push({ row: rowNum, name: batchName, message: msg });
        }
      } else {
        created++;
      }

      if (created % 50 === 0 && created > 0) {
        console.log(`  ${DRY_RUN ? 'Would create' : 'Created'} ${created} batches...`);
      }
    }

    // Save log
    if (!fs.existsSync(LOGS_DIR)) {
      fs.mkdirSync(LOGS_DIR, { recursive: true });
    }
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const logFilename = DRY_RUN
      ? `import-batches-dry-run-${timestamp}.json`
      : `import-batches-${timestamp}.json`;
    const logPath = path.join(LOGS_DIR, logFilename);

    const logOutput = {
      run_at: new Date().toISOString(),
      dry_run: DRY_RUN,
      source_file: excelPath,
      total_rows: totalRows,
      created: created,
      skipped: skipped,
      errors_count: errors.length,
      errors: errors,
    };
    fs.writeFileSync(logPath, JSON.stringify(logOutput, null, 2), 'utf-8');

    console.log('\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('  Import Results');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
    console.log(`Total rows:    ${totalRows}`);
    console.log(`${DRY_RUN ? 'Would create' : 'Created'}:     ${created}`);
    console.log(`Skipped:       ${skipped}`);
    console.log(`Errors:        ${errors.length}`);
    console.log(`\nüìÅ Log saved: ${logPath}\n`);

    if (errors.length > 0 && errors.length <= 20) {
      console.log('Errors:');
      errors.forEach((e, i) => {
        console.log(`  ${i + 1}. Row ${e.row} | ${e.name} | ${e.message}`);
      });
    } else if (errors.length > 20) {
      console.log('First 10 errors:');
      errors.slice(0, 10).forEach((e, i) => {
        console.log(`  ${i + 1}. Row ${e.row} | ${e.name} | ${e.message}`);
      });
    }

    await disconnectDatabase();
    process.exit(errors.length > 0 && created === 0 ? 1 : 0);
  } catch (error) {
    console.error('\n‚ùå Error:', error instanceof Error ? error.message : error);
    await disconnectDatabase();
    process.exit(1);
  }
}

main();
